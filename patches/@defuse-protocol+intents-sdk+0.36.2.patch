diff --git a/node_modules/@defuse-protocol/intents-sdk/dist/src/intents/expirable-nonce.js b/node_modules/@defuse-protocol/intents-sdk/dist/src/intents/expirable-nonce.js
index 7e1a3bf..b5f65c8 100644
--- a/node_modules/@defuse-protocol/intents-sdk/dist/src/intents/expirable-nonce.js
+++ b/node_modules/@defuse-protocol/intents-sdk/dist/src/intents/expirable-nonce.js
@@ -1,6 +1,6 @@
 import { base64 } from "@scure/base";
 import * as v from "valibot";
-import { deserialize } from "near-api-js/lib/utils/serialize";
+import { deserialize } from "near-api-js/lib/utils/serialize.js";
 
 //#region src/intents/expirable-nonce.ts
 const VERSIONED_MAGIC_PREFIX = new Uint8Array([
diff --git a/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js
index eb99204..c3f1c40 100644
--- a/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js
+++ b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js
@@ -19,7 +19,9 @@ import { determineRouteConfig } from "./lib/route-config.js";
 import { SaltManager } from "./intents/salt-manager.js";
 import { IntentPayloadBuilder } from "./intents/intent-payload-builder.js";
 import { PUBLIC_NEAR_RPC_URLS, RETRY_CONFIGS, RelayPublishError, assert, configsByEnvironment, nearFailoverRpcProvider, solverRelay } from "@defuse-protocol/internal-utils";
-import { HotBridge } from "@hot-labs/omni-sdk";
+// import { HotBridge } from "@hot-labs/omni-sdk"; // Patched: Not needed for INTENTS-to-INTENTS swaps
+// Patched: Mock HotBridge class since we don't need it for INTENTS-to-INTENTS swaps
+class HotBridge { constructor(args) { this.args = args; } }
 import { stringify } from "viem";
 import * as v from "valibot";
 
diff --git a/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak
new file mode 100644
index 0000000..eb99204
--- /dev/null
+++ b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak
@@ -0,0 +1,379 @@
+import { FeeExceedsAmountError } from "./classes/errors.js";
+import { Chains } from "./lib/caip2.js";
+import { AuroraEngineBridge } from "./bridges/aurora-engine-bridge/aurora-engine-bridge.js";
+import { DirectBridge } from "./bridges/direct-bridge/direct-bridge.js";
+import { HotBridgeEVMChains } from "./bridges/hot-bridge/hot-bridge-chains.js";
+import { HotBridge as HotBridge$1 } from "./bridges/hot-bridge/hot-bridge.js";
+import { IntentsBridge } from "./bridges/intents-bridge/intents-bridge.js";
+import { OmniBridge } from "./bridges/omni-bridge/omni-bridge.js";
+import { PoaBridge } from "./bridges/poa-bridge/poa-bridge.js";
+import { PUBLIC_EVM_RPC_URLS, PUBLIC_STELLAR_RPC_URLS } from "./constants/public-rpc-urls.js";
+import { VersionedNonceBuilder, saltedNonceSchema } from "./intents/expirable-nonce.js";
+import { DEFAULT_DEADLINE_MS } from "./intents/intent-payload-factory.js";
+import { IntentExecuter } from "./intents/intent-executer-impl/intent-executer.js";
+import { IntentRelayerPublic } from "./intents/intent-relayer-impl/intent-relayer-public.js";
+import { noopIntentSigner } from "./intents/intent-signer-impl/intent-signer-noop.js";
+import { zip } from "./lib/array.js";
+import { configureEvmRpcUrls, configureStellarRpcUrls } from "./lib/configure-rpc-config.js";
+import { determineRouteConfig } from "./lib/route-config.js";
+import { SaltManager } from "./intents/salt-manager.js";
+import { IntentPayloadBuilder } from "./intents/intent-payload-builder.js";
+import { PUBLIC_NEAR_RPC_URLS, RETRY_CONFIGS, RelayPublishError, assert, configsByEnvironment, nearFailoverRpcProvider, solverRelay } from "@defuse-protocol/internal-utils";
+import { HotBridge } from "@hot-labs/omni-sdk";
+import { stringify } from "viem";
+import * as v from "valibot";
+
+//#region src/sdk.ts
+var IntentsSDK = class {
+	constructor(args) {
+		this.env = args.env ?? "production";
+		this.referral = args.referral;
+		this.solverRelayApiKey = args.solverRelayApiKey;
+		const nearRpcUrls = args.rpc?.[Chains.Near] ?? PUBLIC_NEAR_RPC_URLS;
+		assert(nearRpcUrls.length > 0, "NEAR RPC URLs are not provided");
+		const nearProvider = nearFailoverRpcProvider({ urls: nearRpcUrls });
+		const stellarRpcUrls = configureStellarRpcUrls(PUBLIC_STELLAR_RPC_URLS, args.rpc);
+		const evmRpcUrls = configureEvmRpcUrls(PUBLIC_EVM_RPC_URLS, args.rpc, HotBridgeEVMChains);
+		/**
+		* Order of bridges matters, because the first bridge that supports the `withdrawalParams` will be used.
+		* More specific bridges should be placed before more generic ones.
+		*/
+		this.bridges = [
+			new IntentsBridge(),
+			new AuroraEngineBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			}),
+			new PoaBridge({ env: this.env }),
+			new HotBridge$1({
+				env: this.env,
+				solverRelayApiKey: this.solverRelayApiKey,
+				hotSdk: new HotBridge({
+					logger: console,
+					evmRpc: evmRpcUrls,
+					nearRpc: nearRpcUrls,
+					stellarRpc: stellarRpcUrls.soroban,
+					stellarHorizonRpc: stellarRpcUrls.horizon,
+					async executeNearTransaction() {
+						throw new Error("not implemented");
+					}
+				})
+			}),
+			new OmniBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			}),
+			new DirectBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			})
+		];
+		this.intentRelayer = new IntentRelayerPublic({
+			env: this.env,
+			solverRelayApiKey: this.solverRelayApiKey
+		});
+		this.intentSigner = args.intentSigner;
+		this.saltManager = new SaltManager({
+			env: this.env,
+			nearProvider
+		});
+	}
+	setIntentSigner(signer) {
+		this.intentSigner = signer;
+	}
+	/**
+	* Create a new intent payload builder with environment context.
+	* Use this to build custom intent payloads for your API or advanced use cases.
+	*
+	* @returns A new IntentPayloadBuilder instance configured with the SDK's environment
+	*
+	* @example
+	* ```typescript
+	* // Build a custom intent payload
+	* const payload = await sdk.intentBuilder()
+	*   .setSigner('0x1234...') // User's EVM address
+	*   .setDeadline(new Date(Date.now() + 5 * 60 * 1000))
+	*   .addIntent({
+	*     intent: 'ft_withdraw',
+	*     token: 'usdc.omft.near',
+	*     amount: '1000000',
+	*     receiver_id: 'user.near'
+	*   })
+	*   .build();
+	*
+	* // Return to user for signing with their preferred method (MetaMask, etc.)
+	* return payload;
+	* ```
+	*/
+	intentBuilder() {
+		return new IntentPayloadBuilder({
+			env: this.env,
+			saltManager: this.saltManager
+		});
+	}
+	/**
+	* Invalidate multiple nonces by creating and sending empty signed intents.
+	* This prevents previously created but unused intent payloads from being executed.
+	*
+	* For expirable nonces (versioned nonces with embedded deadlines), the intent's
+	* deadline is automatically set to the minimum of:
+	* 1. The nonce's embedded deadline (can't exceed this)
+	* 2. 1 minute from now (for quick invalidation when possible)
+	*
+	* @param args.nonces - Array of nonce strings to invalidate (up to 400 nonces per call, but depends on gas consumption)
+	* @param args.signer - Optional intent signer to use (defaults to SDK's configured signer)
+	* @param args.logger - Optional logger for debugging
+	*
+	* @example
+	* ```typescript
+	* // Invalidate unused nonces
+	* await sdk.invalidateNonces({
+	*   nonces: ['nonce1', 'nonce2', 'nonce3']
+	* });
+	* ```
+	*/
+	async invalidateNonces(args) {
+		if (args.nonces.length === 0) return;
+		const intentSigner = args.signer ?? this.intentSigner;
+		assert(intentSigner != null, "Intent signer is not provided");
+		const signedIntents = await Promise.all(args.nonces.map(async (nonce) => {
+			const builder = this.intentBuilder().setNonce(nonce);
+			try {
+				const decoded = VersionedNonceBuilder.decodeNonce(nonce);
+				if (v.is(saltedNonceSchema, decoded.value)) {
+					const nonceDeadlineMs = Number(decoded.value.inner.deadline / 1000000n);
+					const nonceDeadline = new Date(nonceDeadlineMs);
+					const oneMinuteFromNow = new Date(Date.now() + DEFAULT_DEADLINE_MS);
+					const deadline = oneMinuteFromNow < nonceDeadline ? oneMinuteFromNow : nonceDeadline;
+					builder.setDeadline(deadline);
+				} else args.logger?.warn?.("Decoded nonce has unexpected structure, using default deadline");
+			} catch {}
+			const { signed } = await builder.buildAndSign(intentSigner);
+			return signed;
+		}));
+		await this.intentRelayer.publishIntents({
+			multiPayloads: signedIntents,
+			quoteHashes: []
+		}, { logger: args.logger });
+	}
+	async createWithdrawalIntents(args) {
+		for (const bridge of this.bridges) if (await bridge.supports(args.withdrawalParams)) {
+			const actualAmount = args.withdrawalParams.feeInclusive ? args.withdrawalParams.amount - args.feeEstimation.amount : args.withdrawalParams.amount;
+			await bridge.validateWithdrawal({
+				assetId: args.withdrawalParams.assetId,
+				amount: actualAmount,
+				destinationAddress: args.withdrawalParams.destinationAddress,
+				feeEstimation: args.feeEstimation,
+				routeConfig: args.withdrawalParams.routeConfig,
+				logger: args.logger
+			});
+			return bridge.createWithdrawalIntents({
+				withdrawalParams: {
+					...args.withdrawalParams,
+					amount: actualAmount
+				},
+				feeEstimation: args.feeEstimation,
+				referral: args.referral ?? this.referral
+			});
+		}
+		throw new Error(`Cannot determine bridge for withdrawal = ${stringify(args.withdrawalParams)}`);
+	}
+	estimateWithdrawalFee(args) {
+		if (!Array.isArray(args.withdrawalParams)) return this._estimateWithdrawalFee({
+			...args,
+			withdrawalParams: args.withdrawalParams
+		});
+		return Promise.all(args.withdrawalParams.map((withdrawalParams) => this._estimateWithdrawalFee({
+			...args,
+			withdrawalParams
+		})));
+	}
+	async _estimateWithdrawalFee(args) {
+		for (const bridge of this.bridges) if (await bridge.supports(args.withdrawalParams)) {
+			const fee = await bridge.estimateWithdrawalFee({
+				withdrawalParams: args.withdrawalParams,
+				quoteOptions: args.quoteOptions,
+				logger: args.logger
+			});
+			if (args.withdrawalParams.feeInclusive) {
+				if (args.withdrawalParams.amount <= fee.amount) throw new FeeExceedsAmountError(fee, args.withdrawalParams.amount);
+			}
+			return fee;
+		}
+		throw new Error(`Cannot determine bridge for withdrawal = ${stringify(args.withdrawalParams)}`);
+	}
+	getWithdrawalsIdentifiers({ withdrawalParams, intentTx }) {
+		const indexes = new Map(zip(withdrawalParams.map((w) => {
+			return determineRouteConfig(this, w).route;
+		}), Array(withdrawalParams.length).fill(0)));
+		return withdrawalParams.map((w) => {
+			const routeConfig = determineRouteConfig(this, w);
+			const route = routeConfig.route;
+			const index = indexes.get(route);
+			assert(index != null, "Index is not found for route");
+			indexes.set(route, index + 1);
+			return {
+				routeConfig,
+				index,
+				tx: intentTx
+			};
+		});
+	}
+	async waitForWithdrawalCompletion(args) {
+		const wids = this.getWithdrawalsIdentifiers({
+			withdrawalParams: Array.isArray(args.withdrawalParams) ? args.withdrawalParams : [args.withdrawalParams],
+			intentTx: args.intentTx
+		});
+		const result = await Promise.all(wids.map((wid) => {
+			for (const bridge of this.bridges) if (bridge.is(wid.routeConfig)) return bridge.waitForWithdrawalCompletion({
+				tx: args.intentTx,
+				index: wid.index,
+				routeConfig: wid.routeConfig,
+				signal: args.signal,
+				retryOptions: args.retryOptions,
+				logger: args.logger
+			});
+			throw new Error(`Unsupported route = ${stringify(wid.routeConfig)}`);
+		}));
+		if (Array.isArray(args.withdrawalParams)) return result;
+		assert(result.length === 1, "Unexpected result length");
+		return result[0];
+	}
+	parseAssetId(assetId) {
+		for (const bridge of this.bridges) {
+			const parsed = bridge.parseAssetId(assetId);
+			if (parsed != null) return parsed;
+		}
+		throw new Error(`Cannot determine bridge for assetId = ${assetId}`);
+	}
+	async signAndSendIntent(args) {
+		const intentSigner = args.signer ?? this.intentSigner;
+		assert(intentSigner != null, "Intent signer is not provided");
+		const intentExecuter = new IntentExecuter({
+			env: this.env,
+			logger: args.logger,
+			intentSigner,
+			intentRelayer: this.intentRelayer,
+			intentPayloadFactory: args.payload,
+			onBeforePublishIntent: args.onBeforePublishIntent
+		});
+		const { ticket } = await this.withSaltRetry(args, async (salt) => intentExecuter.signAndSendIntent({
+			intents: args.intents,
+			salt,
+			relayParams: args.relayParams,
+			signedIntents: args.signedIntents
+		}));
+		return { intentHash: ticket };
+	}
+	async withSaltRetry(args, fn) {
+		try {
+			return await fn(await this.saltManager.getCachedSalt());
+		} catch (err) {
+			if (!(err instanceof RelayPublishError && err.code === "INVALID_SALT")) throw err;
+			args.logger?.warn?.("Salt error detected. Refreshing salt and retrying");
+			return fn(await this.saltManager.refresh());
+		}
+	}
+	async signAndSendWithdrawalIntent(args) {
+		let withdrawalParamsArray;
+		let feeEstimations;
+		if (isBatchMode(args)) {
+			withdrawalParamsArray = args.withdrawalParams;
+			feeEstimations = args.feeEstimation;
+		} else {
+			withdrawalParamsArray = [args.withdrawalParams];
+			feeEstimations = [args.feeEstimation];
+		}
+		const intentsP = zip(withdrawalParamsArray, feeEstimations).map(([withdrawalParams, feeEstimation]) => {
+			return this.createWithdrawalIntents({
+				withdrawalParams,
+				feeEstimation,
+				referral: args.referral ?? this.referral,
+				logger: args.logger
+			});
+		});
+		const intents = (await Promise.all(intentsP)).flat();
+		const relayParamsFn = async () => {
+			const relayParams = args.intent?.relayParams != null ? await args.intent?.relayParams() : { quoteHashes: void 0 };
+			const quoteHashes = relayParams.quoteHashes ?? [];
+			for (const fee of feeEstimations) if (fee.quote != null) quoteHashes.push(fee.quote.quote_hash);
+			return {
+				...relayParams,
+				quoteHashes
+			};
+		};
+		return this.signAndSendIntent({
+			intents,
+			signer: args.intent?.signer,
+			onBeforePublishIntent: args.intent?.onBeforePublishIntent,
+			relayParams: relayParamsFn,
+			payload: args.intent?.payload,
+			logger: args.logger,
+			signedIntents: args.intent?.signedIntents
+		});
+	}
+	async waitForIntentSettlement(args) {
+		const { tx } = await new IntentExecuter({
+			env: this.env,
+			logger: args.logger,
+			intentSigner: noopIntentSigner,
+			intentRelayer: this.intentRelayer
+		}).waitForSettlement(args.intentHash);
+		return tx;
+	}
+	async getIntentStatus({ intentHash, logger }) {
+		return solverRelay.getStatus({ intent_hash: intentHash }, {
+			baseURL: configsByEnvironment[this.env].solverRelayBaseURL,
+			logger,
+			solverRelayApiKey: this.solverRelayApiKey
+		});
+	}
+	async processWithdrawal(args) {
+		const withdrawalParams = Array.isArray(args.withdrawalParams) ? args.withdrawalParams : [args.withdrawalParams];
+		const feeEstimation = await (() => {
+			if (args.feeEstimation != null) return Array.isArray(args.feeEstimation) ? args.feeEstimation : [args.feeEstimation];
+			return this.estimateWithdrawalFee({
+				withdrawalParams,
+				logger: args.logger
+			});
+		})();
+		const { intentHash } = await this.signAndSendWithdrawalIntent({
+			withdrawalParams,
+			feeEstimation,
+			referral: args.referral,
+			intent: args.intent,
+			logger: args.logger
+		});
+		const intentTx = await this.waitForIntentSettlement({
+			intentHash,
+			logger: args.logger
+		});
+		const destinationTx = await this.waitForWithdrawalCompletion({
+			withdrawalParams,
+			intentTx,
+			retryOptions: args.retryOptions ?? RETRY_CONFIGS.FIVE_MINS_STEADY,
+			logger: args.logger
+		});
+		if (!Array.isArray(args.withdrawalParams)) return {
+			feeEstimation: feeEstimation[0],
+			intentHash,
+			intentTx,
+			destinationTx: destinationTx[0]
+		};
+		return {
+			feeEstimation,
+			intentHash,
+			intentTx,
+			destinationTx
+		};
+	}
+};
+function isBatchMode(args) {
+	return Array.isArray(args.withdrawalParams);
+}
+
+//#endregion
+export { IntentsSDK };
\ No newline at end of file
diff --git a/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak2 b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak2
new file mode 100644
index 0000000..b0d184b
--- /dev/null
+++ b/node_modules/@defuse-protocol/intents-sdk/dist/src/sdk.js.bak2
@@ -0,0 +1,379 @@
+import { FeeExceedsAmountError } from "./classes/errors.js";
+import { Chains } from "./lib/caip2.js";
+import { AuroraEngineBridge } from "./bridges/aurora-engine-bridge/aurora-engine-bridge.js";
+import { DirectBridge } from "./bridges/direct-bridge/direct-bridge.js";
+import { HotBridgeEVMChains } from "./bridges/hot-bridge/hot-bridge-chains.js";
+import { HotBridge as HotBridge$1 } from "./bridges/hot-bridge/hot-bridge.js";
+import { IntentsBridge } from "./bridges/intents-bridge/intents-bridge.js";
+import { OmniBridge } from "./bridges/omni-bridge/omni-bridge.js";
+import { PoaBridge } from "./bridges/poa-bridge/poa-bridge.js";
+import { PUBLIC_EVM_RPC_URLS, PUBLIC_STELLAR_RPC_URLS } from "./constants/public-rpc-urls.js";
+import { VersionedNonceBuilder, saltedNonceSchema } from "./intents/expirable-nonce.js";
+import { DEFAULT_DEADLINE_MS } from "./intents/intent-payload-factory.js";
+import { IntentExecuter } from "./intents/intent-executer-impl/intent-executer.js";
+import { IntentRelayerPublic } from "./intents/intent-relayer-impl/intent-relayer-public.js";
+import { noopIntentSigner } from "./intents/intent-signer-impl/intent-signer-noop.js";
+import { zip } from "./lib/array.js";
+import { configureEvmRpcUrls, configureStellarRpcUrls } from "./lib/configure-rpc-config.js";
+import { determineRouteConfig } from "./lib/route-config.js";
+import { SaltManager } from "./intents/salt-manager.js";
+import { IntentPayloadBuilder } from "./intents/intent-payload-builder.js";
+import { PUBLIC_NEAR_RPC_URLS, RETRY_CONFIGS, RelayPublishError, assert, configsByEnvironment, nearFailoverRpcProvider, solverRelay } from "@defuse-protocol/internal-utils";
+// import { HotBridge } from "@hot-labs/omni-sdk"; // Patched: Not needed for INTENTS-to-INTENTS swaps
+import { stringify } from "viem";
+import * as v from "valibot";
+
+//#region src/sdk.ts
+var IntentsSDK = class {
+	constructor(args) {
+		this.env = args.env ?? "production";
+		this.referral = args.referral;
+		this.solverRelayApiKey = args.solverRelayApiKey;
+		const nearRpcUrls = args.rpc?.[Chains.Near] ?? PUBLIC_NEAR_RPC_URLS;
+		assert(nearRpcUrls.length > 0, "NEAR RPC URLs are not provided");
+		const nearProvider = nearFailoverRpcProvider({ urls: nearRpcUrls });
+		const stellarRpcUrls = configureStellarRpcUrls(PUBLIC_STELLAR_RPC_URLS, args.rpc);
+		const evmRpcUrls = configureEvmRpcUrls(PUBLIC_EVM_RPC_URLS, args.rpc, HotBridgeEVMChains);
+		/**
+		* Order of bridges matters, because the first bridge that supports the `withdrawalParams` will be used.
+		* More specific bridges should be placed before more generic ones.
+		*/
+		this.bridges = [
+			new IntentsBridge(),
+			new AuroraEngineBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			}),
+			new PoaBridge({ env: this.env }),
+			new HotBridge$1({
+				env: this.env,
+				solverRelayApiKey: this.solverRelayApiKey,
+				hotSdk: new HotBridge({
+					logger: console,
+					evmRpc: evmRpcUrls,
+					nearRpc: nearRpcUrls,
+					stellarRpc: stellarRpcUrls.soroban,
+					stellarHorizonRpc: stellarRpcUrls.horizon,
+					async executeNearTransaction() {
+						throw new Error("not implemented");
+					}
+				})
+			}),
+			new OmniBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			}),
+			new DirectBridge({
+				env: this.env,
+				nearProvider,
+				solverRelayApiKey: this.solverRelayApiKey
+			})
+		];
+		this.intentRelayer = new IntentRelayerPublic({
+			env: this.env,
+			solverRelayApiKey: this.solverRelayApiKey
+		});
+		this.intentSigner = args.intentSigner;
+		this.saltManager = new SaltManager({
+			env: this.env,
+			nearProvider
+		});
+	}
+	setIntentSigner(signer) {
+		this.intentSigner = signer;
+	}
+	/**
+	* Create a new intent payload builder with environment context.
+	* Use this to build custom intent payloads for your API or advanced use cases.
+	*
+	* @returns A new IntentPayloadBuilder instance configured with the SDK's environment
+	*
+	* @example
+	* ```typescript
+	* // Build a custom intent payload
+	* const payload = await sdk.intentBuilder()
+	*   .setSigner('0x1234...') // User's EVM address
+	*   .setDeadline(new Date(Date.now() + 5 * 60 * 1000))
+	*   .addIntent({
+	*     intent: 'ft_withdraw',
+	*     token: 'usdc.omft.near',
+	*     amount: '1000000',
+	*     receiver_id: 'user.near'
+	*   })
+	*   .build();
+	*
+	* // Return to user for signing with their preferred method (MetaMask, etc.)
+	* return payload;
+	* ```
+	*/
+	intentBuilder() {
+		return new IntentPayloadBuilder({
+			env: this.env,
+			saltManager: this.saltManager
+		});
+	}
+	/**
+	* Invalidate multiple nonces by creating and sending empty signed intents.
+	* This prevents previously created but unused intent payloads from being executed.
+	*
+	* For expirable nonces (versioned nonces with embedded deadlines), the intent's
+	* deadline is automatically set to the minimum of:
+	* 1. The nonce's embedded deadline (can't exceed this)
+	* 2. 1 minute from now (for quick invalidation when possible)
+	*
+	* @param args.nonces - Array of nonce strings to invalidate (up to 400 nonces per call, but depends on gas consumption)
+	* @param args.signer - Optional intent signer to use (defaults to SDK's configured signer)
+	* @param args.logger - Optional logger for debugging
+	*
+	* @example
+	* ```typescript
+	* // Invalidate unused nonces
+	* await sdk.invalidateNonces({
+	*   nonces: ['nonce1', 'nonce2', 'nonce3']
+	* });
+	* ```
+	*/
+	async invalidateNonces(args) {
+		if (args.nonces.length === 0) return;
+		const intentSigner = args.signer ?? this.intentSigner;
+		assert(intentSigner != null, "Intent signer is not provided");
+		const signedIntents = await Promise.all(args.nonces.map(async (nonce) => {
+			const builder = this.intentBuilder().setNonce(nonce);
+			try {
+				const decoded = VersionedNonceBuilder.decodeNonce(nonce);
+				if (v.is(saltedNonceSchema, decoded.value)) {
+					const nonceDeadlineMs = Number(decoded.value.inner.deadline / 1000000n);
+					const nonceDeadline = new Date(nonceDeadlineMs);
+					const oneMinuteFromNow = new Date(Date.now() + DEFAULT_DEADLINE_MS);
+					const deadline = oneMinuteFromNow < nonceDeadline ? oneMinuteFromNow : nonceDeadline;
+					builder.setDeadline(deadline);
+				} else args.logger?.warn?.("Decoded nonce has unexpected structure, using default deadline");
+			} catch {}
+			const { signed } = await builder.buildAndSign(intentSigner);
+			return signed;
+		}));
+		await this.intentRelayer.publishIntents({
+			multiPayloads: signedIntents,
+			quoteHashes: []
+		}, { logger: args.logger });
+	}
+	async createWithdrawalIntents(args) {
+		for (const bridge of this.bridges) if (await bridge.supports(args.withdrawalParams)) {
+			const actualAmount = args.withdrawalParams.feeInclusive ? args.withdrawalParams.amount - args.feeEstimation.amount : args.withdrawalParams.amount;
+			await bridge.validateWithdrawal({
+				assetId: args.withdrawalParams.assetId,
+				amount: actualAmount,
+				destinationAddress: args.withdrawalParams.destinationAddress,
+				feeEstimation: args.feeEstimation,
+				routeConfig: args.withdrawalParams.routeConfig,
+				logger: args.logger
+			});
+			return bridge.createWithdrawalIntents({
+				withdrawalParams: {
+					...args.withdrawalParams,
+					amount: actualAmount
+				},
+				feeEstimation: args.feeEstimation,
+				referral: args.referral ?? this.referral
+			});
+		}
+		throw new Error(`Cannot determine bridge for withdrawal = ${stringify(args.withdrawalParams)}`);
+	}
+	estimateWithdrawalFee(args) {
+		if (!Array.isArray(args.withdrawalParams)) return this._estimateWithdrawalFee({
+			...args,
+			withdrawalParams: args.withdrawalParams
+		});
+		return Promise.all(args.withdrawalParams.map((withdrawalParams) => this._estimateWithdrawalFee({
+			...args,
+			withdrawalParams
+		})));
+	}
+	async _estimateWithdrawalFee(args) {
+		for (const bridge of this.bridges) if (await bridge.supports(args.withdrawalParams)) {
+			const fee = await bridge.estimateWithdrawalFee({
+				withdrawalParams: args.withdrawalParams,
+				quoteOptions: args.quoteOptions,
+				logger: args.logger
+			});
+			if (args.withdrawalParams.feeInclusive) {
+				if (args.withdrawalParams.amount <= fee.amount) throw new FeeExceedsAmountError(fee, args.withdrawalParams.amount);
+			}
+			return fee;
+		}
+		throw new Error(`Cannot determine bridge for withdrawal = ${stringify(args.withdrawalParams)}`);
+	}
+	getWithdrawalsIdentifiers({ withdrawalParams, intentTx }) {
+		const indexes = new Map(zip(withdrawalParams.map((w) => {
+			return determineRouteConfig(this, w).route;
+		}), Array(withdrawalParams.length).fill(0)));
+		return withdrawalParams.map((w) => {
+			const routeConfig = determineRouteConfig(this, w);
+			const route = routeConfig.route;
+			const index = indexes.get(route);
+			assert(index != null, "Index is not found for route");
+			indexes.set(route, index + 1);
+			return {
+				routeConfig,
+				index,
+				tx: intentTx
+			};
+		});
+	}
+	async waitForWithdrawalCompletion(args) {
+		const wids = this.getWithdrawalsIdentifiers({
+			withdrawalParams: Array.isArray(args.withdrawalParams) ? args.withdrawalParams : [args.withdrawalParams],
+			intentTx: args.intentTx
+		});
+		const result = await Promise.all(wids.map((wid) => {
+			for (const bridge of this.bridges) if (bridge.is(wid.routeConfig)) return bridge.waitForWithdrawalCompletion({
+				tx: args.intentTx,
+				index: wid.index,
+				routeConfig: wid.routeConfig,
+				signal: args.signal,
+				retryOptions: args.retryOptions,
+				logger: args.logger
+			});
+			throw new Error(`Unsupported route = ${stringify(wid.routeConfig)}`);
+		}));
+		if (Array.isArray(args.withdrawalParams)) return result;
+		assert(result.length === 1, "Unexpected result length");
+		return result[0];
+	}
+	parseAssetId(assetId) {
+		for (const bridge of this.bridges) {
+			const parsed = bridge.parseAssetId(assetId);
+			if (parsed != null) return parsed;
+		}
+		throw new Error(`Cannot determine bridge for assetId = ${assetId}`);
+	}
+	async signAndSendIntent(args) {
+		const intentSigner = args.signer ?? this.intentSigner;
+		assert(intentSigner != null, "Intent signer is not provided");
+		const intentExecuter = new IntentExecuter({
+			env: this.env,
+			logger: args.logger,
+			intentSigner,
+			intentRelayer: this.intentRelayer,
+			intentPayloadFactory: args.payload,
+			onBeforePublishIntent: args.onBeforePublishIntent
+		});
+		const { ticket } = await this.withSaltRetry(args, async (salt) => intentExecuter.signAndSendIntent({
+			intents: args.intents,
+			salt,
+			relayParams: args.relayParams,
+			signedIntents: args.signedIntents
+		}));
+		return { intentHash: ticket };
+	}
+	async withSaltRetry(args, fn) {
+		try {
+			return await fn(await this.saltManager.getCachedSalt());
+		} catch (err) {
+			if (!(err instanceof RelayPublishError && err.code === "INVALID_SALT")) throw err;
+			args.logger?.warn?.("Salt error detected. Refreshing salt and retrying");
+			return fn(await this.saltManager.refresh());
+		}
+	}
+	async signAndSendWithdrawalIntent(args) {
+		let withdrawalParamsArray;
+		let feeEstimations;
+		if (isBatchMode(args)) {
+			withdrawalParamsArray = args.withdrawalParams;
+			feeEstimations = args.feeEstimation;
+		} else {
+			withdrawalParamsArray = [args.withdrawalParams];
+			feeEstimations = [args.feeEstimation];
+		}
+		const intentsP = zip(withdrawalParamsArray, feeEstimations).map(([withdrawalParams, feeEstimation]) => {
+			return this.createWithdrawalIntents({
+				withdrawalParams,
+				feeEstimation,
+				referral: args.referral ?? this.referral,
+				logger: args.logger
+			});
+		});
+		const intents = (await Promise.all(intentsP)).flat();
+		const relayParamsFn = async () => {
+			const relayParams = args.intent?.relayParams != null ? await args.intent?.relayParams() : { quoteHashes: void 0 };
+			const quoteHashes = relayParams.quoteHashes ?? [];
+			for (const fee of feeEstimations) if (fee.quote != null) quoteHashes.push(fee.quote.quote_hash);
+			return {
+				...relayParams,
+				quoteHashes
+			};
+		};
+		return this.signAndSendIntent({
+			intents,
+			signer: args.intent?.signer,
+			onBeforePublishIntent: args.intent?.onBeforePublishIntent,
+			relayParams: relayParamsFn,
+			payload: args.intent?.payload,
+			logger: args.logger,
+			signedIntents: args.intent?.signedIntents
+		});
+	}
+	async waitForIntentSettlement(args) {
+		const { tx } = await new IntentExecuter({
+			env: this.env,
+			logger: args.logger,
+			intentSigner: noopIntentSigner,
+			intentRelayer: this.intentRelayer
+		}).waitForSettlement(args.intentHash);
+		return tx;
+	}
+	async getIntentStatus({ intentHash, logger }) {
+		return solverRelay.getStatus({ intent_hash: intentHash }, {
+			baseURL: configsByEnvironment[this.env].solverRelayBaseURL,
+			logger,
+			solverRelayApiKey: this.solverRelayApiKey
+		});
+	}
+	async processWithdrawal(args) {
+		const withdrawalParams = Array.isArray(args.withdrawalParams) ? args.withdrawalParams : [args.withdrawalParams];
+		const feeEstimation = await (() => {
+			if (args.feeEstimation != null) return Array.isArray(args.feeEstimation) ? args.feeEstimation : [args.feeEstimation];
+			return this.estimateWithdrawalFee({
+				withdrawalParams,
+				logger: args.logger
+			});
+		})();
+		const { intentHash } = await this.signAndSendWithdrawalIntent({
+			withdrawalParams,
+			feeEstimation,
+			referral: args.referral,
+			intent: args.intent,
+			logger: args.logger
+		});
+		const intentTx = await this.waitForIntentSettlement({
+			intentHash,
+			logger: args.logger
+		});
+		const destinationTx = await this.waitForWithdrawalCompletion({
+			withdrawalParams,
+			intentTx,
+			retryOptions: args.retryOptions ?? RETRY_CONFIGS.FIVE_MINS_STEADY,
+			logger: args.logger
+		});
+		if (!Array.isArray(args.withdrawalParams)) return {
+			feeEstimation: feeEstimation[0],
+			intentHash,
+			intentTx,
+			destinationTx: destinationTx[0]
+		};
+		return {
+			feeEstimation,
+			intentHash,
+			intentTx,
+			destinationTx
+		};
+	}
+};
+function isBatchMode(args) {
+	return Array.isArray(args.withdrawalParams);
+}
+
+//#endregion
+export { IntentsSDK };
\ No newline at end of file
